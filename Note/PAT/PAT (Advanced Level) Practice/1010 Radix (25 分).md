https://pintia.cn/problem-sets/994805342720868352/problems/994805511923286016

> 千名教师建设，万道高质量题目，百万用户拼题的程序设计实验辅助教学平台

# 题目详情
Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is `yes`, if 6 is a decimal number and 110 is a binary number.

Now for any pair of positive integers N1N\_1 and N2N\_2, your task is to find the radix of one number while that of the other is given.

### Input Specification:

Each input file contains one test case. Each case occupies a line which contains 4 positive integers:


    N1 N2 tag radix


​    

Here `N1` and `N2` each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, `a`\-`z` } where 0-9 represent the decimal numbers 0-9, and `a`\-`z` represent the decimal numbers 10-35. The last number `radix` is the radix of `N1` if `tag` is 1, or of `N2` if `tag` is 2.

### Output Specification:

For each test case, print in one line the radix of the other number so that the equation `N1` = `N2` is true. If the equation is impossible, print `Impossible`. If the solution is not unique, output the smallest possible radix.

### Sample Input 1:

    6 110 1 10


### Sample Output 1:

    2


### Sample Input 2:

    1 ab 1 2


### Sample Output 2:

    Impossible

# 题解

给出两个数和其中一个数的进制，问是否有可能在另一个数为某个进制时，这两个数相等。如果存在多个可能的进制，输出最小的那个进制。



把已知进制的那个数t转化为十进制，然后对第二个数x的进制进行二分。



- 二分的左边界是x中最大的数字+1（因为要保证x有意义），这个最大的数字可以直接使用`algorithm`中的`max_element`得到。
- 二分的右边界是t+1。如果满足题意的进制存在，那么一般只会有一个，出现多个可能的进制的情况只能是x只有一位数字，而且这一位的值就等于t，这样只要这个x有意义，即所有大于t的进制都可以。但根据题目的约束，一位数能表示的最大值是35，所以当t<36时，右边界为t+1。否则右边界为t（x为10，且进制为t）。二分答案不要求边界是确界，所以也不妨统一右边界为t+1。



在二分答案或进制转换时有可能会出现溢出（值为负）的情况，说明这个数太大了。但是题中给出的信息不足以确定使用什么类型或者是否应该使用大整数，经测试long long可以。

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;
char n1[15], n2[15];

inline int to_num(char a) {  // 把0-9和a-z转换成对应的数字
    if (isdigit(a))
        return a - '0';
    else
        return a - 'a' + 10;
}

ll convert(char x[], int rad) {  // 把rad进制的x转换成10进制
    ll val = 0;
    for (int i = 0, len = strlen(x); i < len; ++i) {
        val = val * rad + to_num(x[i]);
        if (val <= 0)
            return -1; // 溢出返回-1
    }
    return val;
}

ll b_search(char x[], ll target) {  // 二分答案 x：未知进制的数，t：已知进制数的十进制值
    int len = strlen(x);

    ll left = ll(to_num(*max_element(x, x + len))) + 1;  // 左边界是x中最大数字+1
    // ll right = target < 36 ? target + 1 : target;
    ll right = target + 1, mid; // 右边界是t+1

    while (left <= right) {
        mid = (left + right) / 2;
        ll val = convert(x, mid);

        if (val < 0 or val > target)
            right = mid - 1;
        else if (val < target)
            left = mid + 1;
        else if (val == target)
            return mid;
    }
    return -1;
}

int main() {
    int tag, rad;
    scanf("%s %s %d %d", n1, n2, &tag, &rad);

    if (tag == 2)
        swap(n1, n2);

    ll v1 = convert(n1, rad);
    ll n2_rad = b_search(n2, v1);

    if (n2_rad == -1)
        printf("Impossible");
    else
        printf("%lld", n2_rad);
}
```

